#include "movesort.h"
#include "debug.h"
#include "search.h"
#include "hash.h"

// 历史表
int HistoryTable [ 256 * 256 ];

// 清空历史表
void ClearHistoryTable ( void ) {
	memset ( HistoryTable, 0, sizeof HistoryTable );
}

// 更新历史表
void InsertHistoryTable ( const int mv, const int depth ) {
	if ( mv != 0 && !pos.GoodCapMove(mv) ) {
		HistoryTable[mv] += depth * depth;
	}
}

// 生成着法
int MoveSortStruct::InitAlphaBetaMove ( void ) {
	// 1. 初始化
	memset ( move, 0, sizeof move );
	nMoveIndex = 0;
	nMoveNum = 0;

	// 2. 生成所有着法
	pos.GenAllMove ( move, nMoveNum );
	pos.DelMeaningLessMove ( move, nMoveNum );

	// 3. 获得置换表着法
	int hashmv = QueryMoveInHashTable ();

	// 4. 给着法分类赋值
	int type[128];
	for ( int i = 0; i < nMoveNum; i ++ ) {
		type[i] = SORT_TYPE_OTHER;
		if ( hashmv == move[i] ) {
			type[i] = SORT_TYPE_HASHTABLE;
		}
		else if ( pos.square[DST(move[i])] != 0 ) {
			int v = pos.MvvLva ( SRC(move[i]), DST(move[i]) );
			if ( v > 0 ) {
				type[i] = SORT_TYPE_GOOD_CAP;
			}
			else {
				type[i] = SORT_TYPE_OTHER;
			}
		}
		else {
			type[i] = SORT_TYPE_OTHER;
		}
	}

	// 5. 按赋值降序排序
	int t = 0;
	for ( int k = MAX_SORT_TYPE; k >= 0; k -- ) {
		for ( int i = t; i < nMoveNum; i ++ ) {
			if ( type[i] == k ) {
				SWAP ( move[i], move[t] );
				SWAP ( type[i], type[t] );
				t ++;
			}
		}
	}

	// 6. 对GoodCap类按照得分排序


	// 7. 对其他类按历史表排序
	for ( int i = 0; i < nMoveNum; i ++ ) {
		if ( type[i] == SORT_TYPE_OTHER ) {
			for ( int j = i + 1; j < nMoveNum; j ++ ) {
				if ( type[j] == SORT_TYPE_OTHER ) {
					if ( HistoryTable[move[j]] > HistoryTable[move[i]] ) {
						SWAP ( move[i], move[j] );
					}
				}
			}
		}
	}

	return nMoveNum;
}

// 吃子着法估分
int MvvLva ( const int src, const int dst ) const {

}

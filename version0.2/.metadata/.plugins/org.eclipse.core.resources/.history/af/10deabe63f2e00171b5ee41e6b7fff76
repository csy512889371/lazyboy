#include "move.h"
#include "position.h"
#include "search.h"
#include "debug.h"

// 合法数组数据结构的原理
/*
 先用二进制数字表示不同棋子
 车马炮			00000001  1
 将	 			00000010  2
 士   			00000100  4
 象   			00001000  8
 红兵			00010000  16
 黑兵			00100000  32

 然后将棋子数字组合
 车马炮将红兵		00010011 19
 车马炮将黑兵		00100011 35
 车马炮将士红兵	00010111 23
 车马炮将士黑兵	00100111 39
 车马炮将象红兵	00011011 27
 车马炮将象黑兵	00101011 43
 车马炮象红兵		00011001 25
 车马炮象黑兵		00101001 41
 车马炮象红兵黑兵	00111001 57
 车马炮红兵		00010001 17
 车马炮黑兵       00100001 33
 车马炮红兵黑兵	00110001 49
 */
const int LEGAL_POSITION[256] = {
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0,17,17,25,23,19,23,25,17,17, 0, 0, 0, 0,
		0, 0, 0,17,17,17,19,23,19,17,17,17, 0, 0, 0, 0,
		0, 0, 0,25,17,17,23,27,23,17,17,25, 0, 0, 0, 0,
		0, 0, 0,49,17,49,17,49,17,49,17,49, 0, 0, 0, 0,
		0, 0, 0,49,17,57,17,49,17,57,17,49, 0, 0, 0, 0,
		0, 0, 0,49,33,57,33,49,33,57,33,49, 0, 0, 0, 0,
		0, 0, 0,49,33,49,33,49,33,49,33,49, 0, 0, 0, 0,
		0, 0, 0,41,33,33,39,43,39,33,33,41, 0, 0, 0, 0,
		0, 0, 0,33,33,33,35,39,35,33,33,33, 0, 0, 0, 0,
		0, 0, 0,33,33,41,39,35,39,41,33,33, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
const int RED_PAWN_TYPE = 7;
const int BLACK_PAWN_TYPE = 8;
const int POSITION_MASK[] = {2, 4, 8, 1, 1, 1, 0, 16, 32};

int KING_HIT [256][10];	// 将在每个位置的 可达位置，遇0终止
int ADVISOR_HIT [256][10];
int BISHOP_HIT [256][10];
int BISHOP_PIN [256][10]; // 马在每个位置的 马脚，遇0终止
int KNIGHT_HIT [256][10];
int KNIGHT_PIN [256][10];
int PAWN_HIT [256][2][10];

int LOWER_D [1<<16][16][2]; 	// 2进制数 第i个1 低位方向的 第j+1个1 所在的相对位置
int HIGHER_D [1<<16][16][2]; 	// 2进制数 第i个1 高位方向的 第j+1个1 所在的相对位置

int CAN_HIT [2][7][256][256]; // 种类、起点、终点 可行
int PIN_VECTOR_[67]; // 马脚及象脚的向量

void InitMove ( void ) {
	int p = STA_POS;
	int t;

	// 1. HIT & PIN
	// 1.1 初始化
	for ( int i = 0; i < 256; i ++ ) {
		for ( int j = 0; j < 10; j ++ ) {
			 KING_HIT [i][j] = 0;
			 ADVISOR_HIT [i][j] = 0;
			 BISHOP_HIT [i][j] = 0;
			 BISHOP_PIN [i][j] = 0;
			 KNIGHT_HIT [i][j] = 0;
			 KNIGHT_PIN [i][j] = 0;
			 PAWN_HIT [i][0][j] = 0;
			 PAWN_HIT [i][1][j] = 0;
		}
	}
	// 1.2 求结果
	while ( p != 0 ) {
		// 生成将的HIT
		t = 0;
		for ( int i = 0; i < 4 ; i ++ ) {
			int x = p + KING_DIR[i];
			if ( LEGAL_POSITION[x] & POSITION_MASK[ KING_TYPE ] ) {
				KING_HIT[p][t] = x;
				t ++;
			}
		}

		// 生成士的HIT
		t = 0;
		for ( int i = 0; i < 4 ; i ++ ) {
			int x = p + ADVISOR_DIR[i];
			if ( LEGAL_POSITION[x] & POSITION_MASK[ ADVISOR_TYPE ] ) {
				ADVISOR_HIT[p][t] = x;
				t ++;
			}
		}

		// 生成象的HIT及PIN
		t = 0;
		for ( int i = 0; i < 4 ; i ++ ) {
			int x = p + BISHOP_DIR[i];
			if ( LEGAL_POSITION[x] & POSITION_MASK[ BISHOP_TYPE ] ) {
				BISHOP_HIT[p][t] = x;
				BISHOP_PIN[p][t] = p + BISHOP_PIN_DIR[i];
				t ++;
			}
		}

		// 生成马的HIT及PIN
		t = 0;
		for ( int i = 0; i < 8 ; i ++ ) {
			int x = p + KNIGHT_DIR[i];
			if ( LEGAL_POSITION[x] & POSITION_MASK[ KNIGHT_TYPE ] ) {
				KNIGHT_HIT[p][t] = x;
				KNIGHT_PIN[p][t] = p + KNIGHT_PIN_DIR[i];
				t ++;
			}
		}

		// 生成红兵的HIT
		t = 0;
		for ( int i = 0; i < 3; i ++ ) {
			int x = p + RED_PAWN_DIR[i];
			if ( LEGAL_POSITION[x] & POSITION_MASK[ RED_PAWN_TYPE ] ) {
				PAWN_HIT[p][0][t] = x;
				t ++;
			}
		}

		// 生成黑兵的HIT
		t = 0;
		for ( int i = 0; i < 3; i ++ ) {
			int x = p + BLACK_PAWN_DIR[i];
			if ( LEGAL_POSITION[x] & POSITION_MASK[ BLACK_PAWN_TYPE ] ) {
				PAWN_HIT[p][1][t] = x;
				t ++;
			}
		}

		p = NEXTSQ (p);
	}

	// 2. LOWER_D & HIGHER_D
	// 2.1 初始化
	for ( int i = 0; i < (1<<16); i ++ ) {
		for ( int j = 0; j < 16; j ++ ) {
			for ( int k = 0; k < 2; k ++ ) {
				LOWER_D [i][j][k] = 0;
				HIGHER_D [i][j][k] = 0;
			}
		}
	}
	// 2.2 求结果
	for ( int i = 0; i < (1<<16); i ++ ) {
		for ( int j = 0; j < 16; j ++ ) {
			if ( i & (1<<j) ) {
				int t = 0;
				for ( int k = j - 1; k >= 0; k -- ) {
					if ( i & (1<<k) ) {
						LOWER_D [i][j][t] = j - k;
						t ++;
					}
					if ( t > 1 ) {
						break;
					}
				}

				t = 0;
				for ( int k = j + 1; k < 16; k ++ ) {
					if ( i & (1<<k) ) {
						HIGHER_D [i][j][t] = k - j;
						t ++;
					}
					if ( t > 1 ) {
						break;
					}
				}
			}
		}
	}

	// 3. CAN_HIT
	// 3.1 初始化
	for ( int c = 0; c < 2; c ++ ) {
		for ( int t = 0; t < 7; t ++ ) {
			for ( int i = 0; i < 256; i ++ ) {
				for ( int j = 0; j < 256; j ++ ) {
					CAN_HIT[c][t][i][j] = 0;
				}
			}
		}
	}
	// 3.2 求结果
	for ( int p = 0; p < 256; p ++ ) {
		int k;
		// 将
		k = 0;
		while ( KING_HIT[p][k] != 0 ) {
			CAN_HIT[0][KING_TYPE][p][KING_HIT[p][k]] = 1;
			CAN_HIT[1][KING_TYPE][p][KING_HIT[p][k]] = 1;
			k ++;
		}
		// 士
		k = 0;
		while ( ADVISOR_HIT[p][k] != 0 ) {
			CAN_HIT[0][ADVISOR_TYPE][p][ADVISOR_HIT[p][k]] = 1;
			CAN_HIT[1][ADVISOR_TYPE][p][ADVISOR_HIT[p][k]] = 1;
			k ++;
		}
		// 象
		k = 0;
		while ( BISHOP_HIT[p][k] != 0 ) {
			CAN_HIT[0][BISHOP_TYPE][p][BISHOP_HIT[p][k]] = 1;
			CAN_HIT[1][BISHOP_TYPE][p][BISHOP_HIT[p][k]] = 1;
			k ++;
		}
		// 马
		k = 0;
		while ( KNIGHT_HIT[p][k] != 0 ) {
			CAN_HIT[0][KNIGHT_TYPE][p][KNIGHT_HIT[p][k]] = 1;
			CAN_HIT[1][KNIGHT_TYPE][p][KNIGHT_HIT[p][k]] = 1;
			k ++;
		}
		// 兵
		for ( int c = 0; c < 2; c ++ ) {
			k = 0;
			while ( PAWN_HIT[p][c][k] != 0 ) {
				CAN_HIT[c][PAWN_TYPE][p][PAWN_HIT[p][c][k]] = 1;
				k ++;
			}
		}
	}

	// 4. PIN_VECTER
	// 象脚
	for ( int i = 0; i < 4; i ++ ) {
		int mv = BISHOP_DIR[i];
		const int vc = BISHOP_PIN_DIR[i];
		if ( mv < 0 ) {
			mv = - mv * 2;
		}
		PIN_VECTOR_[mv] = vc;
	}
	// 马脚
	for ( int i = 0; i < 8; i ++ ) {
		int mv = KNIGHT_DIR[i];
		const int vc = KNIGHT_PIN_DIR[i];
		if ( mv < 0 ) {
			mv = - mv * 2;
		}
		PIN_VECTOR_[mv] = vc;
	}
}

// 能走
bool PositionStruct::CanHit ( const int pfrom, const int pto ) const {
	if ( !IN_BOARD(pfrom) || !IN_BOARD(pto) ) {
		return false;
	}
	const int ct = COLOR_TYPE ( square[pfrom] );
	if ( ct == 0 ) {
		return false;
	}
	const int sd = ( ct == RED_TYPE ) ? 0 : 1;

	const int type = PIECE_TYPE ( square[pfrom] );
	if ( type == ROOK_TYPE ) {
		const int r = ROW (pfrom);
		const int c = COL (pfrom);
		if ( ROW(pfrom) == ROW(pto) ) {
			if ( pfrom + LOWER_D[ bitRow[r] ][c][0] == pto ) {
				return true;
			}
			if ( pfrom + HIGHER_D[ bitRow[r] ][c][0] == pto ) {
				return true;
			}
		}
		if ( COL(pfrom) == COL(pto) ) {
			if ( pfrom + LOWER_D[ bitCol[c] ][r][0] == pto ) {
				return true;
			}
			if ( pfrom + HIGHER_D[ bitCol[c] ][r][0] == pto ) {
				return true;
			}
		}
	}
	else if ( type == CANNON_TYPE ) {
		const int r = ROW (pfrom);
		const int c = COL (pfrom);
		if ( ROW(pfrom) == ROW(pto) ) {
			if ( pfrom + LOWER_D[bitRow[r]][c][1] == pto ) {
				return true;
			}
			if ( pfrom + HIGHER_D[bitRow[r]][c][1] == pto ) {
				return true;
			}
		}
		if ( COL(pfrom) == COL(pto) ) {
			if ( pfrom + LOWER_D[ bitCol[c] ][r][1] == pto ) {
				return true;
			}
			if ( pfrom + HIGHER_D[ bitCol[c] ][r][1] == pto ) {
				return true;
			}
		}
	}
	else {
		if ( CAN_HIT[sd][type][pfrom][pto] ) {
			return true;
		}
	}
	return false;
}

// 执棋方将军
bool PositionStruct::Check ( void ) const {
	const int ST = SIDE_TYPE (player);
	const int OppSideKingPos = piece [ KING_FROM + OPP_SIDE_TYPE(player) ];

	// 1. 判断马将军
	for ( int i = KNIGHT_FROM; i <= KNIGHT_TO; i ++ ) {
		if ( piece[i+ST] ) {
			if ( CanHit(piece[i+ST], OppSideKingPos) ) {

				return true;
			}
		}
	}

	// 2. 判断车将军
	for ( int i = ROOK_FROM; i <= ROOK_TO; i ++ ) {
		if ( piece[i+ST] ) {
			if ( CanHit(piece[i+ST], OppSideKingPos) ) {
				return true;
			}
		}
	}

	// 3. 判断炮将军
	for ( int i = CANNON_FROM; i <= CANNON_TO; i ++ ) {
		if ( piece[i+ST] ) {
			if ( CanHit(piece[i+ST], OppSideKingPos) ) {
				return true;
			}
		}
	}

	// 4. 判断兵将军
	for ( int i = PAWN_FROM; i <= PAWN_TO; i ++ ) {
		if ( piece[i+ST] ) {
			if ( CanHit(piece[i+ST], OppSideKingPos) ) {
				return true;
			}
		}
	}

	return false;
}

// 执棋方被将军
bool PositionStruct::Checked ( void ) const {
	const int ST = OPP_SIDE_TYPE ( player );
	const int ThisSideKingPos = piece [ KING_FROM + SIDE_TYPE(player) ];

	// 1. 判断被马将军
	for ( int i = KNIGHT_FROM; i <= KNIGHT_TO; i ++ ) {
		if ( piece[i+ST] ) {
			if ( CanHit(piece[i+ST], ThisSideKingPos) ) {
				return true;
			}
		}
	}

	// 2. 判断被车将军
	for ( int i = ROOK_FROM; i <= ROOK_TO; i ++ ) {
		if ( piece[i+ST] ) {
			if ( CanHit(piece[i+ST], ThisSideKingPos) ) {
				return true;
			}
		}
	}

	// 3. 判断被炮将军
	for ( int i = CANNON_FROM; i <= CANNON_TO; i ++ ) {
		if ( piece[i+ST] ) {
			if ( CanHit(piece[i+ST], ThisSideKingPos) ) {
				return true;
			}
		}
	}

	// 4. 判断被兵将军
	for ( int i = PAWN_FROM; i <= PAWN_TO; i ++ ) {
		if ( piece[i+ST] ) {
			if ( CanHit(piece[i+ST], ThisSideKingPos) ) {
				return true;
			}
		}
	}

	return false;
}

// 将对将局面
bool PositionStruct::KingFaceKing ( void ) const {
	int RED_KING_POS = piece [ RED_TYPE + KING_FROM ];
	int BLACK_KING_POS = piece [ BLACK_TYPE + KING_FROM ];

	if ( RED_KING_POS == 0 || BLACK_KING_POS == 0 ) { // 如果将万一不存在，则无解
		return false;
	}
	if ( COL(RED_KING_POS) != COL(BLACK_KING_POS) ) { // 两将必须同列
		return false;
	}

	// 判断两将之间是否有棋子挡住
	int c = COL ( RED_KING_POS );
	int r = ROW ( RED_KING_POS );
	int p;

	p = RED_KING_POS - ( LOWER_D[ bitCol[c] ][r][0] << 4 );
	if ( p == BLACK_KING_POS ) {
		return true;
	}

	p = RED_KING_POS + ( HIGHER_D[ bitCol[c] ][r][0] << 4 );
	if ( p == BLACK_KING_POS ) {
		return true;
	}

	return false;
}

// 生成吃子着法
void PositionStruct::GenCapMove ( int *move, int &nMoveNum ) const {
	int ST = SIDE_TYPE ( player );
	int k, r, c, p;

	// 1. 生成将的吃子着法
	for ( int i = KING_FROM; i <= KING_TO; i ++ ) {
		if ( piece[i+ST] ) {
			k = 0;
			while ( KING_HIT[ piece[i+ST] ][k] != 0 ) {
				int hit = KING_HIT[piece[i+ST]][k];
				if ( square[hit] != 0 && COLOR_TYPE(i+ST) != COLOR_TYPE(square[hit]) ) {
					move[nMoveNum++] = MOVE ( piece[i+ST], hit );
				}
				k ++;
			}
		}
	}

	// 2. 生成士的吃子着法
	for ( int i = ADVISOR_FROM; i <= ADVISOR_TO; i ++ ) {
		if ( piece[i+ST] ) {
			k = 0;
			while ( ADVISOR_HIT[ piece[i+ST] ][k] != 0 ) {
				int hit = ADVISOR_HIT[piece[i+ST]][k];
				if ( square[hit] != 0 && COLOR_TYPE(i+ST) != COLOR_TYPE(square[hit]) ) {
					move[nMoveNum++] = MOVE ( piece[i+ST], hit );
				}
				k ++;
			}
		}
	}

	// 3. 生成象的吃子着法
	for ( int i = BISHOP_FROM; i <= BISHOP_TO; i ++ ) {
		if ( piece[i+ST] ) {
			k = 0;
			while ( BISHOP_HIT[ piece[i+ST] ][k] != 0 ) {
				int hit = BISHOP_HIT[piece[i+ST]][k];
				if ( square[hit] != 0 && COLOR_TYPE(i+ST) != COLOR_TYPE(square[hit]) ) {
					int pin = BISHOP_PIN[piece[i+ST]][k];
					if ( square[pin] == 0 ) { // 象脚
						move[nMoveNum++] = MOVE ( piece[i+ST], hit );
					}
				}
				k ++;
			}
		}
	}

	// 4. 生成马的吃子着法
	for ( int i = KNIGHT_FROM; i <= KNIGHT_TO; i ++ ) {
		if ( piece[i+ST] ) {
			k = 0;
			while ( KNIGHT_HIT[ piece[i+ST] ][k] != 0 ) {
				int hit = KNIGHT_HIT[piece[i+ST]][k];
				if ( square[hit] != 0 && COLOR_TYPE(i+ST) != COLOR_TYPE(square[hit]) ) {
					int pin = KNIGHT_PIN[piece[i+ST]][k];
					if ( square[pin] == 0 ) { // 马脚
						move[nMoveNum++] = MOVE ( piece[i+ST], hit );
					}
				}
				k ++;
			}
		}
	}

	// 5. 生成车的吃子着法
	for ( int i = ROOK_FROM; i <= ROOK_TO; i ++ ) {
		if ( piece[i+ST] ) {
			r = ROW ( piece[i+ST] );
			c = COL ( piece[i+ST] );

			p = piece[i+ST] - ( LOWER_D[ bitCol[c] ][r][0] << 4 );
			if ( COLOR_TYPE(i+ST) != COLOR_TYPE(square[p]) ) {
				move[nMoveNum++] = MOVE ( piece[i+ST], p );
			}

			p = piece[i+ST] + ( HIGHER_D[ bitCol[c] ][r][0] << 4 );
			if ( COLOR_TYPE(i+ST) != COLOR_TYPE(square[p]) ) {
				move[nMoveNum++] = MOVE ( piece[i+ST], p );
			}

			p = piece[i+ST] - LOWER_D [ bitRow[r] ][c][0];
			if ( COLOR_TYPE(i+ST) != COLOR_TYPE(square[p]) ) {
				move[nMoveNum++] = MOVE ( piece[i+ST], p );
			}

			p = piece[i+ST] + HIGHER_D [ bitRow[r] ][c][0];
			if ( COLOR_TYPE(i+ST) != COLOR_TYPE(square[p]) ) {
				move[nMoveNum++] = MOVE ( piece[i+ST], p );
			}
		}
	}

	// 6. 生成炮的吃子着法
	for ( int i = CANNON_FROM; i <= CANNON_TO; i ++ ) {
		if ( piece[i+ST] ) {
			r = ROW ( piece[i+ST] );
			c = COL ( piece[i+ST] );

			p = piece[i+ST] - ( LOWER_D[ bitCol[c] ][r][1] << 4 );
			if ( COLOR_TYPE(i+ST) != COLOR_TYPE(square[p]) ) {
				move[nMoveNum++] = MOVE ( piece[i+ST], p );
			}

			p = piece[i+ST] + ( HIGHER_D[ bitCol[c] ][r][1] << 4 );
			if ( COLOR_TYPE(i+ST) != COLOR_TYPE(square[p]) ) {
				move[nMoveNum++] = MOVE ( piece[i+ST], p );
			}

			p = piece[i+ST] - LOWER_D [ bitRow[r] ][c][1];
			if ( COLOR_TYPE(i+ST) != COLOR_TYPE(square[p]) ) {
				move[nMoveNum++] = MOVE ( piece[i+ST], p );
			}

			p = piece[i+ST] + HIGHER_D [ bitRow[r] ][c][1];
			if ( COLOR_TYPE(i+ST) != COLOR_TYPE(square[p]) ) {
				move[nMoveNum++] = MOVE ( piece[i+ST], p );
			}
		}
	}

	// 7. 生成兵的吃子着法
	for ( int i = PAWN_FROM; i <= PAWN_TO; i ++ ) {
		if ( piece[i+ST] ) {
			k = 0;
			while ( PAWN_HIT[piece[i+ST]][player][k] != 0 ) {
				int hit = PAWN_HIT[piece[i+ST]][player][k];
				if ( square[hit] != 0 && COLOR_TYPE(i+ST) != COLOR_TYPE(square[hit]) ) {
					move[nMoveNum++] = MOVE ( piece[i+ST], hit );
				}
				k ++;
			}
		}
	}
}

// 生成非吃子着法
void PositionStruct::GenNonCapMove ( int *move, int &nMoveNum ) const {
	int ST = SIDE_TYPE ( player );
	int k;

	// 1. 生成将的非吃子着法
	for ( int i = KING_FROM; i <= KING_TO; i ++ ) {
		if ( piece[i+ST] ) {
			k = 0;
			while ( KING_HIT[ piece[i+ST] ][k] != 0 ) {
				int hit = KING_HIT[piece[i+ST]][k];
				if ( square[hit] == 0 ) {
					move[nMoveNum++] = MOVE ( piece[i+ST], hit );
				}
				k ++;
			}
		}
	}

	// 2. 生成士的非吃子着法
	for ( int i = ADVISOR_FROM; i <= ADVISOR_TO; i ++ ) {
		if ( piece[i+ST] ) {
			k = 0;
			while ( ADVISOR_HIT[ piece[i+ST] ][k] != 0 ) {
				int hit = ADVISOR_HIT[piece[i+ST]][k];
				if ( square[hit] == 0 ) {
					move[nMoveNum++] = MOVE ( piece[i+ST], hit );
				}
				k ++;
			}
		}
	}

	// 3. 生成象的非吃子着法
	for ( int i = BISHOP_FROM; i <= BISHOP_TO; i ++ ) {
		if ( piece[i+ST] ) {
			k = 0;
			while ( BISHOP_HIT[ piece[i+ST] ][k] != 0 ) {
				int hit = BISHOP_HIT[piece[i+ST]][k];
				if ( square[hit] == 0 ) {
					int pin = BISHOP_PIN[piece[i+ST]][k];
					if ( square[pin] == 0 ) { // 象脚
						move[nMoveNum++] = MOVE ( piece[i+ST], hit );
					}
				}
				k ++;
			}
		}
	}

	// 4. 生成马的非吃子着法
	for ( int i = KNIGHT_FROM; i <= KNIGHT_TO; i ++ ) {
		if ( piece[i+ST] ) {
			k = 0;
			while ( KNIGHT_HIT[ piece[i+ST] ][k] != 0 ) {
				int hit = KNIGHT_HIT[piece[i+ST]][k];
				if ( square[hit] == 0 ) {
					int pin = KNIGHT_PIN[piece[i+ST]][k];
					if ( square[pin] == 0 ) { // 马脚
						move[nMoveNum++] = MOVE ( piece[i+ST], hit );
					}
				}
				k ++;
			}
		}
	}

	// 5. 生成车的非吃子着法
	for ( int i = ROOK_FROM; i <= ROOK_TO; i ++ ) {
		if ( piece[i+ST] ) {
			for ( int j = 0; j < 4; j ++ ) {
				int hit = piece[i+ST];
				int meetTime = 0;
				while ( true ) {
					hit = hit + DIR[j];
					if ( ! IN_BOARD(hit) ) {
						break;
					}
					if ( square[hit] != 0 ) {
						meetTime ++;
					}
					if ( meetTime > 0 ) {
						break;
					}
					move[nMoveNum++] = MOVE ( piece[i+ST], hit );
				}
			}
		}
	}

	// 6. 生成炮的非吃子着法
	for ( int i = CANNON_FROM; i <= CANNON_TO; i ++ ) {
		if ( piece[i+ST] ) {
			for ( int j = 0; j < 4; j ++ ) {
				int hit = piece[i+ST];
				int meetTime = 0;
				while ( true ) {
					hit = hit + DIR[j];
					if ( ! IN_BOARD(hit) ) {
						break;
					}
					if ( square[hit] != 0 ) {
						meetTime ++;
					}
					if ( meetTime > 0 ) {
						break;
					}
					move[nMoveNum++] = MOVE ( piece[i+ST], hit );
				}
			}
		}
	}

	// 7. 生成兵的非吃子着法
	for ( int i = PAWN_FROM; i <= PAWN_TO; i ++ ) {
		if ( piece[i+ST] ) {
			k = 0;
			while ( PAWN_HIT[piece[i+ST]][player][k] != 0 ) {
				int hit = PAWN_HIT[piece[i+ST]][player][k];
				if ( square[hit] == 0 ) {
					move[nMoveNum++] = MOVE ( piece[i+ST], hit );
				}
				k ++;
			}
		}
	}
}

// 生成所有着法
void PositionStruct::GenAllMove ( int *move, int &nMoveNum ) const {
	GenCapMove ( move, nMoveNum );
	GenNonCapMove ( move, nMoveNum );
}

// 去除无意义着法，无意义着法包括：1.被将军的着法  2.将对将的着法
void PositionStruct::DelMeaningLessMove ( int *move, int &nMoveNum ) {
	for ( int i = 0; i < nMoveNum; i ++ ) {
		MakeMove ( move[i] );
		if ( check || KingFaceKing() ) {
			SWAP ( move[i], move[nMoveNum-1] );
			nMoveNum --;
			i --;
		}
		UndoMakeMove ();
	}
}

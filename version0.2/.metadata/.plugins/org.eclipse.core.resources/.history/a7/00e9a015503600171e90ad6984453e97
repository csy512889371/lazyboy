#include "movesort.h"
#include "debug.h"
#include "search.h"
#include "hash.h"

// 历史表
int HistoryTable [ 256 * 256 ];

// 清空历史表
void ClearHistoryTable ( void ) {
	memset ( HistoryTable, 0, sizeof HistoryTable );
}

// 更新历史表
void InsertHistoryTable ( const int mv, const int depth ) {
	if ( mv != 0 && !pos.GoodCapMove(mv) ) { // !
		HistoryTable[mv] += depth * depth;
	}
}

// 生成着法
int MoveSortStruct::InitAlphaBetaMove ( void ) {
	// 1. 初始化
	memset ( move, 0, sizeof move );
	nMoveIndex = 0;
	nMoveNum = 0;

	// 2. 生成所有着法
	pos.GenAllMove ( move, nMoveNum );
	pos.DelMeaningLessMove ( move, nMoveNum );

	// 3. 获得置换表着法
	int hashmv = QueryMoveInHashTable ();

	// 4. 给着法分类赋值
	int type[128];
	for ( int i = 0; i < nMoveNum; i ++ ) {
		type[i] = SORT_TYPE_OTHER;
		if ( hashmv == move[i] ) {
			type[i] = SORT_TYPE_HASHTABLE;
		}
		else if ( pos.square[DST(move[i])] != 0 ) {
			int v = pos.MvvLva ( SRC(move[i]), DST(move[i]) );
			if ( v > 0 ) {
				type[i] = SORT_TYPE_GOOD_CAP;
			}
			else {
				type[i] = SORT_TYPE_OTHER;
			}
		}
		else {
			type[i] = SORT_TYPE_OTHER;
		}
	}

	// 5. 按赋值降序排序
	int t = 0;
	for ( int k = MAX_SORT_TYPE; k >= 0; k -- ) {
		for ( int i = t; i < nMoveNum; i ++ ) {
			if ( type[i] == k ) {
				SWAP ( move[i], move[t] );
				SWAP ( type[i], type[t] );
				t ++;
			}
		}
	}

	// 6. 对GoodCap类按照得分降序排序
	for ( int i = 0; i < nMoveNum; i ++ ) {
		if ( type[i] == SORT_TYPE_GOOD_CAP ) {
			for ( int j = i + 1; j < nMoveNum; j ++ ) {
				if ( type[j] == SORT_TYPE_GOOD_CAP ) {
					int vi = pos.MvvLva ( SRC(move[i]), DST(move[i]) );
					int vj = pos.MvvLva ( SRC(move[j]), DST(move[j]) );
					if ( vi < vj ) {
						SWAP ( move[i], move[j] );
					}
				}
			}
		}
	}

	// 7. 对Other类按历史表降序排序
	for ( int i = 0; i < nMoveNum; i ++ ) {
		if ( type[i] == SORT_TYPE_OTHER ) {
			for ( int j = i + 1; j < nMoveNum; j ++ ) {
				if ( type[j] == SORT_TYPE_OTHER ) {
					if ( HistoryTable[move[i]] < HistoryTable[move[j]] ) {
						SWAP ( move[i], move[j] );
					}
				}
			}
		}
	}

	return nMoveNum;
}

// 将5, 士1, 象1, 马3, 车4, 炮3, 兵2
const int SIMPLE_VALUE[7] = {5, 1, 1, 3, 4, 3, 2};

// 吃子着法估分
int MvvLva ( const int src, const int dst ) const {

}
